#!/usr/bin/env python3

# pylint: disable=invalid-name
# pylint: disable=too-many-locals
# pylint: disable=consider-using-f-string

from datetime import datetime
import argparse
import os
import sys
import re
import subprocess
import shlex
import urllib.parse
import numpy as np
import matplotlib.pyplot as plt
import nbformat
from nbformat.v4 import new_notebook, new_code_cell, new_markdown_cell
from scipy.optimize import curve_fit

def scattered_light(g=0, n=1, quad_pts=4):
    """Max scattered light for all optical thicknesses.""" 
    b = np.logspace(-5,5,200)
    r_white, t_white, _, _ = iad.Sample(a=1, b=b, g=g, n=n, quad_pts=quad_pts).rt()
    r_black, t_black, _, _ = iad.Sample(a=0, b=b, g=g, n=n, quad_pts=quad_pts).rt()

    xy = np.array([r_white-r_black, t_white-t_black]).T
    return xy

def active_polygon():
    """Unscattered light for all optical thicknesses.""" 
    xy = np.array([[1,0], [0,1], [0,0]])
    return plt.Polygon(xy, closed=True, facecolor='b', alpha=0.2)

def plot_good_and_bad(x, y, success, big_points=False):
    if big_points:
        size = 5
    else :
        size = 1
    if any(success):
        plt.plot(x[success], y[success], marker='o', markersize=size,
                 markerfacecolor='none', markeredgecolor='blue', linestyle='None',
                 label='fit')

    if any(~success):
        plt.plot(x[~success], y[~success], 'xr', label='failed')
        plt.legend()
    plt.xlabel('Wavelength (nm)')
    plt.grid(True)

def plot_gridlines(filename_base):
    gridname = filename_base + '-grid.txt'
    a,b,g,mr,mt = np.loadtxt(gridname, skiprows=2, delimiter=',').T

    with open(gridname, 'r') as file:
        cmd = file.readline()
    cmd = cmd[2:]
    cmd = cmd.replace('-J ', '')

    N = len(a)

    a_list = list(set(a))
    for aa in a_list:
        r = [mr[i] for i in range(N) if a[i] == aa]
        t = [mt[i] for i in range(N) if a[i] == aa]
        plt.plot(r, t, 'k', lw=0.5)
        plt.text(r[-1],t[-1], 'a=%g' % aa, ha='center', va='top')

    b_list = list(set(b))
    for bb in b_list:
        r = [mr[i] for i in range(N) if b[i] == bb]
        t = [mt[i] for i in range(N) if b[i] == bb]
        plt.plot(r, t, 'k', lw=0.5)
        plt.text(r[-1],t[-1], 'b=%g' % bb)

    r = [mr[i] for i in range(N) if a[i] == 1]
    t = [mt[i] for i in range(N) if a[i] == 1]
    r1 = [mr[i] for i in range(N) if b[i] == 100]
    t1 = [mt[i] for i in range(N) if b[i] == 100]
    r = r + r1[::-1]
    t = t + t1[::-1]
    rt = np.array([r,t]).T
    poly = plt.Polygon(rt, closed=True, facecolor='y', alpha=0.2)
    plt.gca().add_patch(poly)
    
    plt.plot(r, t, 'k', lw=0.5)
    plt.text(r[-1],t[-1], 'a=%g' % aa, ha='center', va='top')
    plt.title(cmd)
    plt.grid(False)

def plot_grid(mr, cr, mt, ct, success, filename_base):
    out_filename = filename_base + '-grid.svg'
    plt.figure(figsize=(8,8))
    plt.gca().set_aspect(1)
    plt.xlim(-0.05,1.05)
    plt.ylim(-0.05,1.05)
    plt.xticks(fontsize=12)
    plt.yticks(fontsize=12)
    plot_good_and_bad(cr, ct, success, True)
    plt.plot(mr, mt, 'ok', markersize=2, label='measured')
#    plt.gca().add_patch(active_polygon())
    plot_gridlines(filename_base)
    plt.xlabel('MR',fontsize=12)
    plt.ylabel('MT',fontsize=12)
    plt.legend()
    plt.savefig(out_filename, dpi=300)
    plt.close()
    return os.path.basename(out_filename)


def plot_rt(lam, mr, mt, filename_base):
    """Plot measured r, t, and u."""
    out_filename = filename_base + '-RTU.svg'
    plt.figure(figsize=(8, 4.5))
    plt.plot(lam, mr, 'ob', markersize=2, label='r')
    plt.plot(lam, mt, 'or', markersize=2, label='t')
    plt.plot(lam, mr+mt, 'ok', markersize=2, label='r+t')
    plt.ylabel('Measurement')
    plt.xlabel('Wavelength (nm)')
    plt.legend()
    plt.grid(True)
    plt.savefig(out_filename, dpi=300)
    plt.close()
    return os.path.basename(out_filename)

def plot_r(lam, mr, cr, success, filename_base):
    """Plot measured reflection and fitted reflection."""
    out_filename = filename_base + '-R.svg'
    plt.figure(figsize=(8, 4.5))
    plot_good_and_bad(lam, cr, success, True)
    plt.plot(lam, mr, 'ok', markersize=2, label='measured')
    plt.ylabel('Reflection')
    plt.legend()
    plt.savefig(out_filename, dpi=300)
    plt.close()
    return os.path.basename(out_filename)


def plot_t(lam, mt, ct, success, filename_base):
    """Plot measured reflection and fitted transmission."""
    out_filename = filename_base + '-T.svg'
    plt.figure(figsize=(8, 4.5))
    plot_good_and_bad(lam, ct, success, True)
    plt.plot(lam, mt, 'ok', markersize=2, label='measured')
    plt.ylabel('Transmission')
    plt.legend()
    plt.savefig(out_filename, dpi=300)
    plt.close()
    return os.path.basename(out_filename)


def plot_mua(lam, mua, success, filename_base):
    """Plot calculated absorption coefficient."""
    out_filename = filename_base + '-mua.svg'
    plt.figure(figsize=(8, 4.5))
    plot_good_and_bad(lam, mua, success)
    plt.ylabel('Absorption Coefficient (mm⁻¹)')
    plt.savefig(out_filename, dpi=300)
    plt.close()
    return os.path.basename(out_filename)

# Define the function you want to fit
def scattering_model(x, a, b):
    return a * (x / 1000) ** (-b)

def plot_musp(lam, musp, success, filename_base, fit=False):
    """Plot calculated reduced scattering coefficient."""
    out_filename = filename_base + '-musp.svg'
    plt.figure(figsize=(8, 4.5))
    plot_good_and_bad(lam, musp, success)
    if fit:
        popt, pcov = curve_fit(scattering_model, lam[success], musp[success])
        a_opt, b_opt = popt
        lamb = np.linspace(min(lam), max(lam))
        fn_str = "musp=%g * (lamba_nm/1000)**(-%g)" % (a_opt, b_opt)
        plt.plot(lamb, scattering_model(lamb, a_opt, b_opt), label=fn_str)
        plt.legend()

    plt.ylabel('Reduced Scattering Coefficient (mm⁻¹)')
    plt.savefig(out_filename, dpi=300)
    plt.close()
    return os.path.basename(out_filename)


def plot_mus(lam, mus, success, filename_base, fit=False):
    """Plot calculated scattering coefficient."""
    out_filename = filename_base + '-mus.svg'
    plt.figure(figsize=(8, 4.5))
    plot_good_and_bad(lam, mus, success)
    if fit:
        popt, pcov = curve_fit(scattering_model, lam[success], mus[success])
        a_opt, b_opt = popt
        lamb = np.linspace(min(lam), max(lam))
        fn_str = "mus=%g * (lamba_nm/1000)**(-%g)" % (a_opt, b_opt)
        plt.plot(lamb, scattering_model(lamb, a_opt, b_opt), label=fn_str)
        plt.legend()
    plt.ylabel('Scattering Coefficient (mm⁻¹)')
    plt.savefig(out_filename, dpi=300)
    plt.close()
    return os.path.basename(out_filename)


def plot_g(lam, g, success, filename_base):
    """Plot calculated scattering coefficient."""
    out_filename = filename_base + '-g.svg'
    plt.figure(figsize=(8, 4.5))
    plot_good_and_bad(lam, g, success)
    plt.ylabel('Scattering Anisotropy')
    plt.savefig(out_filename, dpi=300)
    plt.close()
    return os.path.basename(out_filename)

def plot_a(lam, a, success, filename_base):
    """Plot calculated albedo."""
    out_filename = filename_base + '-a.svg'
    plt.figure(figsize=(8, 4.5))
    plot_good_and_bad(lam, a, success)
    plt.ylabel(r'Single Scattering Albedo $\mu_s/(\mu_a+\mu_s)$')
    plt.savefig(out_filename, dpi=300)
    plt.close()
    return os.path.basename(out_filename)

def plot_b(lam, b, success, filename_base):
    """Plot calculated scattering coefficient."""
    out_filename = filename_base + '-b.svg'
    plt.figure(figsize=(8, 4.5))
    plot_good_and_bad(lam, b, success)
    plt.ylabel(r'Optical Thickness $(\mu_a+\mu_s)d$')
    plt.savefig(out_filename, dpi=300)
    plt.close()
    return os.path.basename(out_filename)

def append_graph_cell(nb, header, graph):
    cell_text = header + "\n"
    url_encoded_filename = urllib.parse.quote(graph)
    cell_text += "<center>\n"
    cell_text += '    <img src="' + url_encoded_filename + '" width="80%" />\n'
    cell_text += "</center>\n"
    nb.cells.append(new_markdown_cell(cell_text))


def append_file_cell(nb, header, file):
    base = os.path.basename(file)
    cell_text = header + '\n'
    cell_text += 'with open("' + base + '", "r", encoding="utf-8") as file:\n'
    cell_text += '    file_contents = file.read()\n'
    cell_text += '\n'
    cell_text += 'print(file_contents)\n'
    nb.cells.append(new_code_cell(cell_text))


def get_thickness(output_filename):
    # Inverse Adding-Doubling 3-15-2 (8 Mar 2024)
    # iad -M 0 -o /Users/prahl/Documents/Code/git/iad/test/basic-B.txt test/basic-B.rxt
    with open(output_filename, 'r', encoding='utf-8') as file:
        file.readline()
        file.readline()
        file.readline()
        fourth_line = file.readline()

    pattern = r'=\s*(\d+\.?\d*)'
    match = re.search(pattern, fourth_line)
    d_str = match.group(1)
    return float(d_str)


def append_header(nb, output_filename):
    # Inverse Adding-Doubling 3-15-2 (8 Mar 2024)
    # iad -M 0 -o /Users/prahl/Documents/Code/git/iad/test/basic-B.txt test/basic-B.rxt
    with open(output_filename, 'r', encoding='utf-8') as file:
        first_line = file.readline()
        second_line = file.readline()

    pattern = r'(\d+-\d+-\d+) \((\d+ \w+ \d+)\)'
    match = re.search(pattern, first_line)
    if not match:
        raise ValueError('File %s contains bad contents' % output_filename)
    version = match.group(1)
    build = match.group(2)

    today = datetime.today()
    formatted_date = today.strftime('%d %b %Y')

    cell_text = "# Inverse Adding-Doubling Analysis\n\n"
    cell_text += "iad version %s built on %s\n\n" % (version,build)
    cell_text += "This analysis was done on %s\n\n" % formatted_date
    cell_text += "The command-line was\n\n"
    cell_text += "    " + second_line + "\n"
    nb.cells.append(new_markdown_cell(cell_text))

def main():
    desc =  'A wrapper for the iad program that creates a Jupyter notebook with plots '
    desc += 'of the input, the fitted results, and the derived optical properties.'
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('input_files', nargs='+', help='List of .rxt files to process')
    parser.add_argument('-options', metavar='OPTIONS', type=str, nargs='?',
                        help='options to pass to iad program, e.g., "-c 0"')
    parser.add_argument('--force', action='store_true',
                        help='Force reanalysis of files')
    parser.add_argument('--fit', action='store_true',
                        help='Fit scattering data to a*(λ/1000nm)**(-b)')
    args = parser.parse_args()

    # You can then iterate over this list to open and process each file
    for file_name in args.input_files:

        abs_dir = os.path.abspath(os.path.dirname(file_name))
        local_dir = os.path.dirname(file_name)
        base = os.path.splitext(os.path.basename(file_name))[0]

        base_path = os.path.join(local_dir, base)
        out_path = os.path.join(local_dir, base + '.txt')
        ipynb_path = os.path.join(local_dir, base + '.ipynb')

        if not os.path.exists(base_path + '.rxt'):
            print('missing file "%s"' % (base_path + '.rxt'))
            sys.exit()

        if not os.path.exists(base_path + '.txt') or args.force:
            command = ['iad']
            if args.options:
                command.extend(shlex.split(args.options))
            command.append('-J')
            command.extend([shlex.quote(file_name)])
            command_str = ' '.join(command)

            print('running:', command_str)
            subprocess.run(command, shell=False, check=True)

        if os.path.exists(base_path + '.ipynb') and not args.force:
            continue

        result = np.loadtxt(out_path, skiprows=44, usecols=range(8), delimiter='\t')
        lam, mr, cr, mt, ct, mua, musp, g = result.T
        lam = np.atleast_1d(lam)
        mr = np.atleast_1d(mr)
        cr = np.atleast_1d(cr)
        mt = np.atleast_1d(mt)
        ct = np.atleast_1d(ct)
        mua = np.atleast_1d(mua)
        musp = np.atleast_1d(musp)
        g = np.atleast_1d(g)

        converters = {8: lambda s: s.strip()}
        status = np.loadtxt(out_path, usecols=[8], dtype=str, converters=converters)
        status = np.atleast_1d(status)
        success = status == '*'

        d = get_thickness(out_path)
        mus = musp/(1-g)
        b = (mua + mus)*d

        denominator = mua + mus
        safe_denominator = np.where(denominator == 0, np.inf, denominator)
        a = mus / safe_denominator

        rt_graph = plot_rt(lam, mr, mt, base_path)
        r_graph = plot_r(lam, mr, cr, success, base_path)
        t_graph = plot_t(lam, mt, ct, success, base_path)
        mua_graph = plot_mua(lam, mua, success, base_path)
        musp_graph = plot_musp(lam, musp, success, base_path, fit=args.fit)
        mus_graph = plot_mus(lam, mus, success, base_path, fit=args.fit)
        a_graph = plot_a(lam, a, success, base_path)
        b_graph = plot_b(lam, b, success, base_path)
        g_graph = plot_g(lam, g, success, base_path)
        grid_graph = plot_grid(mr, cr, mt, ct, success, base_path)

        nb = new_notebook()
        nb.metadata['kernelspec'] = {
            'display_name': 'Python 3',
            'language': 'python',
            'name': 'python3'
        }

        append_header(nb, out_path)
        append_graph_cell(nb, '## Reflection', r_graph)
        append_graph_cell(nb, '## Transmission', t_graph)
        append_graph_cell(nb, '## Absorption Coefficient', mua_graph)
        append_graph_cell(nb, '## Reduced Scattering Coefficient', musp_graph)
        append_graph_cell(nb, '## Single Scattering Albedo', a_graph)
        append_graph_cell(nb, '## Optical Thickness', b_graph)
        append_graph_cell(nb, '## Scattering Anisotropy', g_graph)
        append_graph_cell(nb, '## Scattering Coefficient', mus_graph)
        append_graph_cell(nb, '## Original Measurements', rt_graph)
        append_graph_cell(nb, '## Grid Graph', grid_graph)

        nb.cells.append(new_markdown_cell("## Input file\n"))
        append_file_cell(nb, '# input file', base + '.rxt')

        nb.cells.append(new_markdown_cell("## Output file\n"))
        append_file_cell(nb, '# output file', base + '.txt')

        # Save the notebook
        with open(ipynb_path, "w", encoding="utf-8") as f:
            nbformat.write(nb, f)


if __name__ == "__main__":
    main()
